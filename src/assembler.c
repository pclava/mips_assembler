#include "assembler.h"

#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include "utils.h"
#include "pseudoinstructions.h"
#include "instructions.h"

/*
 Assembler

 Takes as input a Text structure generated by the Preprocessor and the path to the output file
 Performs two passes:
  - The first pass parses the lines from the input into instructions and data,
      and adds symbol declarations to the symbol table.
      It returns InstructionList, DataList, and SymbolTable structures.
  - The second pass converts each instruction into its 32-bit machine code representation
      by consulting the InstructionTable and writes it to the output file, consulting
      the symbol table when needed. It then writes the raw data to file.

 Both passes take as input an Assembler structure, which contains pointers to the
  Text, InstructionList, DataList, SymbolTable, and InstructionTable structures. This is generated by the main
  assemble() function.
*/

enum DataType CURRENT_DIRECTIVE = WORD; // Keeps track of the type of data item being stored; assumes WORD by default

/* === FIRST PASS TEXT SEGMENT === */

// Parses a string into an Instruction. Does most of the heavy-lifting for this part of the assembler.
int parse_instruction(const Assembler *assembler, const char *line, Instruction *instruction) {
    memset(instruction->mnemonic, '\0', sizeof(instruction->mnemonic));

    const Immediate imm = {NONE, .intValue=0, .modifier=0};
    instruction->imm = imm;

    char line_buf[strlen(line) + 1]; // Tokenize a copy so we preserve original string
    strcpy(line_buf, line);

    char *token = tokenize(line_buf, ' ');
    int argc = 0;
    unsigned char args[3];
    int readMnemonic = 0; // Whether the mnemonic has been read. Set to true when the assembler finds the first token not ending in ':'

    char label[SYMBOL_SIZE];

    // Loop through each token
    while (token != NULL) {
        size_t len = strlen(token);

        // Check if token is a label
        if (token[len-1] == ':') {
            // Check for errors
            if (readMnemonic || len <= 1) { // Labels should not be empty and should not come after the mnemonic
                raise_error(SYMBOL_INV, token, __FILE__);
                return 0;
            }
            if (isnumber(token[0])) {
                raise_error(SYMBOL_INV, token, __FILE__);
                return 0;
            }

            // Copy over symbol
            for (size_t i = 0; i < len-1; i++) {
                if (!isalnum(token[i])) {
                    raise_error(SYMBOL_INV, token, __FILE__);
                    return 0;
                }
                label[i] = token[i];
            }
            label[len-1] = '\0';

            // Add to symbol table (assumes local, but if it exists as global, will preserve that binding)
            st_add_symbol(assembler->symbol_table, label, assembler->instruction_list->text_offset, TEXT, LOCAL);
        }

        // Read mnemonic. This will catch the first token not ending in ':' and set readMnemonic to true.
        else if (!readMnemonic) {
            if (len >= MNEMONIC_LENGTH) {
                raise_error(SIZE_ERR, token, __FILE__);
                return 0;
            }
            strcpy(instruction->mnemonic, token);
            readMnemonic = 1;
        }

        // Process arguments
        else {
            if (argc >= 3) {
                raise_error(ARG_INV, token, __FILE__);
                return 0;
            }

            if (token[len-1] == ',') {
                len--;
                token[len] = '\0';
            } // Remove comma

            // Read register
            if (token[0] == '$') {

                const unsigned char r = get_register(token);
                if (r == 255) {
                    raise_error(ARG_INV, token, __FILE__);
                    return 0;
                }

                args[argc] = r;
                argc++;
            }

            // Argument isn't a register, so assume it's an immediate
            else {
                instruction->imm = parse_imm(token);
                if (instruction->imm.modifier == 255) {
                    return 0;
                }
                token = tokenize(NULL, ' ');
                if (token != NULL) { // Make sure there's no arguments after
                    raise_error(ARG_INV, token, __FILE__);
                    return 0;
                }

                // Check symbol
                if (instruction->imm.type == SYMBOL) {
                    if (st_exists(assembler->symbol_table, instruction->imm.symbol) == SYMBOL_TABLE_SIZE) {
                        // Doesn't exist yet, add as local undefined. may be made global later
                        st_add_symbol(assembler->symbol_table, instruction->imm.symbol, 0, UNDEF, LOCAL);
                    }
                }

                break;
            }
        }

        token = tokenize(NULL, ' ');
    }

    // Add registers
    int i;
    for (i = 0; i < argc; i++) { // Add registers to list
        instruction->registers[i] = args[i];
    }
    while (i < 3) { // Fill remaining spaces with 255
        instruction->registers[i] = 255;
        i++;
    }

    return 1;
}

// Adds Instruction to InstructionList. Converts pseudoinstructions if needed.
int process_instruction(const Instruction instruction, InstructionList *instruction_list) {

    // Replace pseudo-instructions
    const int s = process_pseudo(instruction, instruction_list); // Number of instructions written
    if (s == -1) {
        return 0;
    } // Processing failed

    if (s == 0) { // Instruction was not a pseudoinstruction
        if (add_instruction(instruction_list, instruction) == 0) return 0; // add instruction
        return 1;
    }

    // Instruction was a pseudoinstruction
    return 1;
}

// Parses and processes a Line containing an instruction.
int read_text(const Assembler *assembler, const Line *line) {

    Instruction instruction;
    if (parse_instruction(assembler, line->text, &instruction) == 0) {
        return 0;
    }
    instruction.line = line;

    // Add to instruction list
    if (process_instruction(instruction, assembler->instruction_list) == 0) return 0;

    return 1;
}

/* === FIRST PASS DATA SEGMENT === */

// Processes a Line containing data. Parses and adds to the DataList simultaneously.
int read_data(const Assembler *assembler, const Line *line) {

    char line_buffer[strlen(line->text) + 1]; // Use a separate buffer to avoid overwriting the input string
    strcpy(line_buffer, line->text);

    // Tokenize
    char *token = tokenize(line_buffer, ' ');
    int argc = 0; // Number of data items stored
    int readDirective = 0; // Whether the directive has been read. Set to true by the assembler when it finds the first token not ending in ':'

    char labels[16][SYMBOL_SIZE]; // Supports up to 16 labels at a time. Should be enough. Who is declaring 16 duplicate labels?
    size_t label_count = 0;
    memset(labels, '\0', sizeof(labels));

    size_t argument_size = 32;
    char *argument = malloc(argument_size);
    if (argument == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }

    while (token != NULL) {
        const size_t len = strlen(token);
        if (len <= 0) continue;

        // Token is a label
        if (token[len-1] == ':') {
            // Set aside label, add to symbol list later
            // We set it aside because the directive may add padding before the data it stores and we don't know the directive yet
            if (strlen(token) <= 1 || readDirective) { // Labels should not be empty and should precede the mnemonic
                raise_error(SYMBOL_INV, token, __FILE__);
                free(argument);
                return 0;
            }
            if (isnumber(token[0])) {
                raise_error(SYMBOL_INV, token, __FILE__);
                free(argument);
                return 0;
            }

            for (size_t i = 0; i < strlen(token)-1; i++) {
                if (!isalnum(token[i])) {
                    raise_error(SYMBOL_INV, token, __FILE__);
                    free(argument);
                    return 0;
                }
                labels[label_count][i] = token[i];
            }
            labels[label_count][strlen(token)-1] = '\0';
            label_count++;

            token = tokenize(NULL, ' ');
            continue;
        }

        // Token is a directive; update CURRENT_DIRECTIVE and sets readDirective to 1.
        if (!readDirective) { // Catches the first token not ending in ':'
            char directive[7];
            strncpy(directive, token+1, strlen(token)); // copy just the name
            if (read_directive(directive, &CURRENT_DIRECTIVE) == 0) {
                free(argument);
                return 0;
            }
            readDirective = 1;
        }

        // Token is an argument (i.e., a data item to store)
        else {
            if (CURRENT_DIRECTIVE == ALIGN) {
                if (argc != 0) { // Should only have one argument
                    raise_error(ARGS_INV, NULL, __FILE__);
                    free(argument);
                    return 0;
                }

                // Parse to integer
                if (add_aligned(line, token, assembler->data_list) == 0) {
                    free(argument);
                    return 0;
                }

                // Save label(s) (after alignment)
                if (labels[0][0] != '\0') {
                    for (size_t i = 0; i < label_count; i++) {
                        if (st_add_symbol(assembler->symbol_table, labels[i], assembler->data_list->data_offset, DATA, LOCAL) == 0) {
                            free(argument);
                            return 0;
                        }
                    }
                }

            }
            else if (CURRENT_DIRECTIVE == SPACE) {
                if (argc != 0) {
                    free(argument);
                    raise_error(ARGS_INV, NULL, __FILE__);
                    return 0;
                }

                // Save label(s) (before adding space)
                if (labels[0][0] != '\0') {
                    for (size_t i = 0; i < label_count; i++) {
                        if (st_add_symbol(assembler->symbol_table, labels[i], assembler->data_list->data_offset, DATA, LOCAL) == 0) {
                            free(argument);
                            return 0;
                        }
                    }
                }

                // Parse to integer
                if (add_space(line, token, assembler->data_list) == 0) {
                    free(argument);
                    return 0;
                }
            }
            else {
                memset(argument, '\0', argument_size);

                // Argument is a string; note I keep the first quote to differentiate strings from other data (namely labels)
                if (token[0] == '"') {
                    argument = read_string(argument, &argument_size, token);
                    if (argument == NULL) {
                        return 0;
                    }
                }

                // Argument is not a string
                else {
                    if (len >= argument_size) {
                        argument_size *= 2;
                        char *new = realloc(argument, argument_size);
                        if (new == NULL) {
                            raise_error(MEM, NULL, __FILE__);
                            free(argument);
                            return 0;
                        }
                        argument = new;
                    }
                    strcpy(argument, token);
                }

                // Create data object
                Data data;
                data.line = line;
                if (process_data(&data, CURRENT_DIRECTIVE, argument) == 0) {
                    free(argument);
                    return 0;
                }

                // Add any necessary padding
                if (data_pad(data, assembler->data_list) == 0) {
                    free(argument);
                    return 0;
                }

                // Write the label(s)
                if (labels[0][0] != '\0') {
                    for (size_t i = 0; i < label_count; i++) {
                        if (st_add_symbol(assembler->symbol_table, labels[i], assembler->data_list->data_offset, DATA, LOCAL) == 0) {
                            free(argument);
                            return 0;
                        }
                    }
                }

                // Add to data list and increment data_addr
                if (add_data(assembler->data_list, data) == 0) {
                    free(argument);
                    return 0;
                }
            }
            argc++;
            memset(labels, '\0', sizeof(labels));
        }

        token = tokenize(NULL, ' ');
    }

    if (CURRENT_DIRECTIVE == ALIGN || CURRENT_DIRECTIVE == SPACE) CURRENT_DIRECTIVE = WORD; // .align and .space directives don't survive next line

    free(argument);

    return 1;
}

/* === SECOND PASS TEXT SEGMENT === */

// Returns the 32-bit machine code representation of the Instruction, or -1 on failure.
uint32_t convert_instruction(const Instruction instruction, const Assembler* assembler, const uint32_t current_addr) {
    // Get function description
    const InstrDesc *instruction_desc = it_lookup(assembler->instruction_table, instruction.mnemonic);
    if (instruction_desc == NULL) return -1;

    switch (instruction_desc->format) {
        case R:
            return convert_rtype(instruction, instruction_desc);
        case I:
            return convert_itype(instruction, assembler->symbol_table, assembler->relocation_table, instruction_desc, current_addr);
        case J:
            return convert_jtype(instruction, assembler->symbol_table, assembler->relocation_table, instruction_desc, current_addr);
        default:
            raise_error(NOERR, NULL, __FILE__);
            return -1;
    }
}

// Goes through every instruction and writes its 32-bit machine code to the file. Returns 0 on failure
int write_instruction_list(FILE *file, const Assembler *assembler) {
    uint32_t current_addr = 0;

    for (size_t i = 0; i < assembler->instruction_list->len; i++) {
        const Instruction instruction = assembler->instruction_list->list[i];
        ERROR_HANDLER.line = instruction.line;

        // Convert to machine code
        const uint32_t machine_code = convert_instruction(instruction, assembler, current_addr);
        if (machine_code == (uint32_t) -1) {
            return 0;
        }

        // Write 32-bit instruction to file
        if (write_word(file, machine_code) == 0) {
            ERROR_HANDLER.err_code = FILE_IO;
            return 0;
        }

        current_addr += 4;
    }
    return 1;
}

/* === SECOND PASS DATA SEGMENT === */

// Writes a Data structure to the file
int write_data(FILE *file, Data data, const SymbolTable *symbol_table) {
    if (data.isSymbol) {

        Symbol *s = st_get_symbol(symbol_table, data.value.symbol);
        if (s == NULL) return 0;
        uint32_t target_offset = s->offset;

        switch (data.type) {
            case WORD:
                data.value.word = (int32_t) target_offset;
                break;
            case HALF:
                data.value.half = (int16_t) (target_offset & 0x0000FFFF);
                break;
            case BYTE:
                data.value.byte = (int8_t) (target_offset & 0x000000FF);
                break;
            default:
                raise_error(ARGS_INV, NULL, __FILE__);
                return 0;
        }
    }

    unsigned long success;
    if (data.type == STRING || data.type == STRING_NT) {
        success = write_string(file, data.value.string, data.size);
        if (success == 0) {
            ERROR_HANDLER.err_code = FILE_IO;
            return 0;
        }
        return 1;
    }

    if (data.type == SPACE) {
        for (size_t i = 0; i < data.size; i++) {
            success = write_byte(file, 0);
            if (success == 0) {
                ERROR_HANDLER.err_code = FILE_IO;
                return 0;
            }
        }
        return 1;
    }

    success = fwrite(&data.value, data.size, 1, file);
    if (success == 0) {
        ERROR_HANDLER.err_code = FILE_IO;
        return 0;
    }
    return 1;

}

// Goes through every Data structure in the list and writes it to file. Returns 0 on failure or -1 on file IO failure.
int write_data_list(FILE *file, Assembler *assembler) {
    for (size_t i = 0; i < assembler->data_list->len; i++) {
        const Data data = assembler->data_list->list[i];
        ERROR_HANDLER.line = data.line;

        const int success = write_data(file, data, assembler->symbol_table);
        if (success <= 0) return success;
    }
    return 1;
}

/* === MAIN === */

// Parses the output of the preprocessor into the symbol table, instruction list, and data list.
int assembler_first_pass(Assembler *assembler) {

    enum Segment current_segment = TEXT;

    // Loop through each individual line in the file
    for (size_t i = 0; i < assembler->preprocessed->len; i++) {
        const Line *line = &assembler->preprocessed->items[i];
        ERROR_HANDLER.line = line;

        // Read directive
        if (line->text[0] == '.') {
            char directive[7];
            char c = line->text[1];
            int j = 0;
            while (!isspace(c) && c != '\0') {
                directive[j] = c;
                j++;
                c = line->text[j+1];
            }
            directive[j] = '\0';

            if (strcmp(directive, "text") == 0) {
                current_segment = TEXT;
                continue;
            }
            if (strcmp(directive, "data") == 0) {
                current_segment = DATA;
                continue;
            }
            if (strcmp(directive, "globl") == 0) {
                // Add all arguments to symbol table as global undefined symbols
                char line_cpy[strlen(line->text)+1];
                strcpy(line_cpy,line->text);
                const char *token = tokenize(line_cpy, ' ');
                token = tokenize(NULL, ' '); // tokenize again to skip the directive
                if (token == NULL) {
                    raise_error(ARGS_INV, NULL, __FILE__);
                    return 0;
                }
                while (token != NULL) {
                    const unsigned long index = st_exists(assembler->symbol_table, token);
                    if (index == SYMBOL_TABLE_SIZE) { // symbol does not exist
                        st_add_symbol(assembler->symbol_table, token, 0, UNDEF, GLOBAL);
                    } else { // symbol exists; make global
                        assembler->symbol_table->buckets[index].item.binding = GLOBAL;
                    }

                    token = tokenize(NULL, ' ');
                }
                continue;
            }
            if (current_segment != DATA) { // Any other directive must be in the data segment
                raise_error(TOKEN_ERR, directive, __FILE__);
                return 0;
            }
        }

        // TEXT
        if (current_segment == TEXT) {
            if (read_text(assembler, line) == 0) {
                return 0;
            }
        }

        // DATA
        else if (current_segment == DATA){
            if (read_data(assembler, line) == 0) {
                return 0;
            }
        }
    }

    return 1;
}

// Processes the output of the first pass and writes the result to file
int assembler_second_pass(Assembler *assembler, const char *output) {

    ERROR_HANDLER.line = NULL;

    // === Open output file ===
    FILE *file = fopen(output, "wb");
    if (file == NULL) {
        raise_error(FILE_IO, output, __FILE__);
        return 0;
    }

    // === Write Header ===
    struct FileHeader header;
    header.text_size = assembler->instruction_list->text_offset;
    header.data_size = assembler->data_list->data_offset;
    header.rlc_size = 0;
    header.sym_size = 0;
    fwrite(&header, sizeof(header), 1, file);

    // === Write Instructions ===
    int success = write_instruction_list(file, assembler);
    if (success == 0) {
        if (ERROR_HANDLER.err_code == FILE_IO) {
            raise_error(FILE_IO, output, __FILE__);
        }
        fclose(file);
        return 0;
    }

    // == Write Data ===
    success = write_data_list(file, assembler);
    if (success == 0) {
        if (ERROR_HANDLER.err_code == FILE_IO) {
            raise_error(FILE_IO, output, __FILE__);
        }
        fclose(file);
        return 0;
    }

    fclose(file);
    return 1;
}

// Converts the output of the preprocessor into machine code and writes it to file
int assemble(const Text *preprocessed, const char *output) {
    Assembler assembler;
    if (assembler_init(&assembler, preprocessed) == 0) {
        assembler_destroy(&assembler);
        return 0;
    }

    if (assembler_first_pass(&assembler) == 0) {
        assembler_destroy(&assembler);
        return 0;
    }

    // Check for undefined local symbols and make global
    // This behavior essentially automatically imports any undefined symbol
    for (int i = 0; i < SYMBOL_TABLE_SIZE; i++) {
        if (assembler.symbol_table->buckets[i].inUse) {
            if (assembler.symbol_table->buckets[i].item.segment == UNDEF) {
                assembler.symbol_table->buckets[i].item.binding = GLOBAL;
            }
        }
    }

    if (assembler_second_pass(&assembler, output) == 0) {
        assembler_destroy(&assembler);
        return 0;
    }

    assembler_debug(&assembler);
    assembler_destroy(&assembler);
    return 1;
}

// Allocates memory for and initializes the components of the assembler given the output of the preprocessor
int assembler_init(Assembler *assembler, const Text *preprocessed) {
    assembler->preprocessed = preprocessed;
    assembler->symbol_table = NULL;
    assembler->data_list = NULL;
    assembler->instruction_list = NULL;
    assembler->instruction_table = NULL;

    // Initialize symbol table
    SymbolTable *symbol_table = malloc(sizeof(SymbolTable));
    if (symbol_table == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }
    if (st_init(symbol_table) == 0) return 0;
    assembler->symbol_table = symbol_table;

    // Initialize instruction list
    InstructionList *instruction_list = malloc(sizeof(InstructionList));
    if (instruction_list == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }
    if (il_init(instruction_list, 0) == 0) return 0;
    assembler->instruction_list = instruction_list;

    // Initialize data list
    DataList *data_list = malloc(sizeof(DataList));
    if (data_list == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }
    if (dl_init(data_list, 0) == 0) return 0;
    assembler->data_list = data_list;

    // Initialize instruction table
    InstructionTable *instruction_table = malloc(sizeof(InstructionTable));
    if (instruction_table == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }
    if (it_create(instruction_table) == 0) return 0;
    assembler->instruction_table = instruction_table;

    // Initialize relocation table
    RelocationTable *relocation_table = malloc(sizeof(RelocationTable));
    if (relocation_table == NULL) {
        raise_error(MEM, NULL, __FILE__);
        return 0;
    }
    if (rt_init(relocation_table) == 0) return 0;
    assembler->relocation_table = relocation_table;

    return 1;
}

// Frees the resources of the assembler and its components
void assembler_destroy(Assembler *assembler) {
    if (assembler->data_list != NULL) {
        dl_destroy(assembler->data_list);
        free(assembler->data_list);
    }
    if (assembler->instruction_list != NULL) {
        il_destroy(assembler->instruction_list);
        free(assembler->instruction_list);
    }
    if (assembler->symbol_table != NULL) {
        st_destroy(assembler->symbol_table);
        free(assembler->symbol_table);
    }
    if (assembler->instruction_table != NULL) {
        it_destroy(assembler->instruction_table);
    }
    if (assembler->relocation_table != NULL) {
        rt_destroy(assembler->relocation_table);
    }
}

void assembler_debug(const Assembler *assembler) {
    if (assembler->symbol_table != NULL) {
        st_debug(assembler->symbol_table);
    } else {
        printf("No symbol table found\n");
    }

    if (assembler->data_list != NULL) {
        dl_debug(assembler->data_list);
    } else {
        printf("No data list found\n");
    }

    if (assembler->instruction_list != NULL) {
        il_debug(assembler->instruction_list);
    } else {
        printf("No instruction list found\n");
    }

    if (assembler->relocation_table != NULL) {
        rt_debug(assembler->relocation_table);
    } else {
        printf("No relocation table found\n");
    }
}
